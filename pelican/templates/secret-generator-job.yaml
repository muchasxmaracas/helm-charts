apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "pelican.fullname" . }}-secret-gen
  annotations:
    # ArgoCD specific hook to run before the sync
    "argocd.argoproj.io/hook": PreSync
    "argocd.argoproj.io/hook-delete-policy": BeforeHookCreation
spec:
  template:
    spec:
      serviceAccountName: {{ include "pelican.fullname" . }}-secret-mgr
      restartPolicy: OnFailure
      containers:
      - name: generate
        image: bitnami/kubectl:latest
        command:
        - /bin/sh
        - -c
        - |
          # Check if the secret already has an APP_KEY
          EXISTING_KEY=$(kubectl get secret mysql-config -n {{ .Release.Namespace }} -o jsonpath='{.data.APP_KEY}' 2>/dev/null)

          if [ -z "$EXISTING_KEY" ]; then
            echo "Secret or APP_KEY missing. Generating new secure credentials..."
            
            USER_PASS=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 24)
            ROOT_PASS=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 24)
            # Laravel requires a base64 encoded 32-byte string
            APP_KEY="base64:$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32 | base64)"
            
            # Use 'apply' or 'create' logic that doesn't fail if parts exist
            kubectl create secret generic mysql-config \
              --from-literal=MARIADB_USER={{ .Values.database.config.user | default "pelican" }} \
              --from-literal=MARIADB_PASSWORD=$USER_PASS \
              --from-literal=DB_PASSWORD=$USER_PASS \
              --from-literal=MARIADB_ROOT_PASSWORD=$ROOT_PASS \
              --from-literal=MARIADB_DATABASE={{ .Values.database.config.database | default "pelican" }} \
              --from-literal=APP_KEY=$APP_KEY \
              -n {{ .Release.Namespace }} \
              --dry-run=client -o yaml | kubectl apply f -
            
            echo "Secret 'mysql-config' synchronized successfully."
          else
            echo "APP_KEY already exists in cluster. Skipping generation to prevent data loss."
          fi